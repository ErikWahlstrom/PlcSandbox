<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#

    var serviceProvider = this.Host as IServiceProvider;
    var dte = serviceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
    var solutionDirectory = System.IO.Path.GetDirectoryName(dte.Solution.FullName);

	var trees = ParsePlcSymbolFile.ReadFile(solutionDirectory + "\\PlcSandbox\\PlcTest.tmc");
    WriteLine($"// ReSharper disable InconsistentNaming");
    WriteLine($"// ReSharper disable CheckNamespace");
    WriteLine($"#pragma warning disable SA1300 // Element must begin with upper-case letter");
    WriteLine($"#pragma warning disable SA1649 // File name must match first type name");
    WriteLine($"#pragma warning disable SA1402 // File may only contain a single class");   
    WriteLine($"namespace GeneratedAddress");
    WriteLine("{");
    PushIndent("    ");        
    WriteLine($"using TwinCatAdsCommunication.Address;");
    WriteLine(string.Empty);
	foreach(var tree in trees)		
	{
        PrintTree(tree, false);        
    }		
    PopIndent();
    WriteLine("}");
    WriteLine($"#pragma warning restore SA1300 // Element must begin with upper-case letter");  
    WriteLine($"#pragma warning restore SA1649 // File name must match first type name");
    WriteLine($"#pragma warning restore SA1402 // File may only contain a single class");    
#>

<#+	

    // This code could possibly be copy pasted from som actual class but for now I'll leave it here since it uses PushIndent, PopIndent etc.
    public void PrintTree(ClassTree tree, bool child)
    {
        if (child)
        {
            WriteLine(string.Empty);
        }
        WriteLine($"public static class {tree.Name}");
        WriteLine("{");
        PushIndent("    ");
        var written = false;        
        foreach (var prop in tree.Symbols)
        {
            if (written)
            {
                WriteLine(string.Empty);
            }
            written = true;
            switch (prop.Type)
            {
                case "BOOL":
                    WriteLine($"public static BoolAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new BoolAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "BYTE":
                    WriteLine($"public static ByteAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new ByteAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "REAL":
                    WriteLine($"public static FloatAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new FloatAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "UDINT":
                    WriteLine($"public static UintAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new UintAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "UINT":
                    WriteLine($"public static UshortAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new UshortAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "INT":
                    WriteLine($"public static ShortAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new ShortAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "DINT":
                    WriteLine($"public static IntAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new IntAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "LREAL":
                    WriteLine($"public static DoubleAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new DoubleAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "DWORD":
                    WriteLine($"public static UintAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new UintAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;
                case "WORD":
                    WriteLine($"public static ShortAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new ShortAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                    break;                
                default :
                    if (prop.Type.StartsWith("STRING"))
                    {
                        WriteLine($"public static StringAddressUnconnected {prop.Name.Split('.').Last()} {{ get; }} = new StringAddressUnconnected({prop.BitSize}, \"{prop.Name}\");");
                        break;
                    }
                    else
                    {
                        written = false;
                    }
                    break;
            }
        }

        if (tree.Children != null)
        {
            PrintTree(tree.Children, true);            
        }
      
        PopIndent();
        WriteLine("}");
        if (!child)
        {
            WriteLine(string.Empty);
            
}
                        
}

    // Insert copy paste-code here from ReadPlcSymbolFile


    public class ParsePlcSymbolFile
    {
        public static IEnumerable<ClassTree> ReadFile(string path)
        {
            var xml = XDocument.Load(path);
            var dataAreas = xml.Root.Descendants(XName.Get("DataArea"));
            var classNames = new List<string>();

            var symbols = new List<PlcSymbol>();

            foreach (var dataArea in dataAreas)
            {
                var distinctName = dataArea.Descendants(XName.Get("Symbol")).Elements().Where(x => x.Name == "Name").Select(y=>y.Value.ToString()).Distinct();
                foreach (var dist in distinctName)
                {
                    var splitted = dist.Split('.');
                    var currentClassName = string.Join(".", splitted.Take(splitted.Length - 1));
                    if (classNames.Any(x => x.Contains(currentClassName) && x.StartsWith(currentClassName)))
                    {
                        continue;
                    }

                    var existingClassName = classNames.SingleOrDefault(x => currentClassName.Contains(x) && currentClassName.StartsWith(x));
                    if (existingClassName != null)
                    {
                        classNames.Remove(existingClassName);
                    }

                    classNames.Add(currentClassName);
                }

                foreach (var symbol in dataArea.Descendants(XName.Get("Symbol")))
                {
                    symbols.Add(new PlcSymbol(symbol.Element("Name").Value, symbol.Element("BaseType").Value, int.Parse(symbol.Element("BitSize").Value), int.Parse(symbol.Element("BitOffs").Value)));
                }
            }

            var trees = new List<ClassTree>();

            foreach (var nameSpace in classNames.Distinct())
            {
                trees.Add(new ClassTree(nameSpace));
            }

            foreach (var plcSymbol in symbols)
            {
                MapToTree(trees, plcSymbol);
            }

            return trees;
        }

        public static void MapToTree(IEnumerable<ClassTree> trees, PlcSymbol symbol)
        {
            var choppedUpSymbol = symbol.Name.Split('.');
            var possibleTrees = trees;
            for (int i = 0; i < choppedUpSymbol.Length - 2; i++)
            {
                possibleTrees = possibleTrees.Where(x => x.Name == choppedUpSymbol[i]).Select(x => x.Children).ToArray();
            }
            if (!possibleTrees.Any())
            {
                throw new InvalidOperationException("Free flying symbol...");
            }
            possibleTrees.Single(x => x.Name == choppedUpSymbol[choppedUpSymbol.Length - 2]).AddSymbol(symbol);
        }
    }

    public class PlcSymbol
    {
        public PlcSymbol(string name, string type, int bitSize, int bitOffset)
        {
            Name = name;
            Type = type;
            BitSize = bitSize;
            BitOffset = bitOffset;
        }

        public string Name { get; }

        public string Type { get; }

        public int BitSize { get; }

        public int BitOffset { get; }
    }

    public class ClassTree
    {
        public ClassTree(string name)
        {
            Symbols = new List<PlcSymbol>();
            if (name.Contains("."))
            {
                Name = name.Remove(name.IndexOf("."));
                this.Children = new ClassTree(name.Remove(0, name.IndexOf(".") + 1));
            }
            else
            {
                Name = name;
            }
        }

        public string Name { get; }

        public ClassTree Children { get; }

        public void AddSymbol(PlcSymbol symbol)
        {
            this.Symbols.Add(symbol);
        }

        public IList<PlcSymbol> Symbols { get; }
    }
	

    //End of copy paste code
#>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#

    var serviceProvider = this.Host as IServiceProvider;
    var dte = serviceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
    var solutionDirectory = System.IO.Path.GetDirectoryName(dte.Solution.FullName);

	var trees = ParsePlcSymbolFile.ReadFile(solutionDirectory + "\\PlcSandbox\\PrinterPlc.tmc");
				ClassTree currentTree;
    WriteLine($"namespace GeneratedAddress");
    WriteLine("{");
    PushIndent("\t");        
    WriteLine($"using TwinCatAdsCommunication.Address;");
	foreach(var tree in trees)		
	{
        PrintTree(tree);
    }		
    PopIndent();
    WriteLine("}");      
#>

<#+	

    // This code could possibly be copy pasted from som actual class but for now I'll leave it here since it uses PushIndent, PopIndent etc.
    public void PrintTree(ClassTree tree)
    {
        WriteLine($"public static class {tree.Name}");
        WriteLine("{");
        PushIndent("\t");        
        foreach (var prop in tree.Symbols)
        {
            switch (prop.Type)
            {
                case "BOOL":
                    WriteLine($"public static BoolAddress {prop.Name.Split('.').Last()} {{ get; }} = new BoolAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "BYTE":
                    WriteLine($"public static ByteAddress {prop.Name.Split('.').Last()} {{ get; }} = new ByteAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "REAL":
                    WriteLine($"public static FloatAddress {prop.Name.Split('.').Last()} {{ get; }} = new FloatAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "UDINT":
                    WriteLine($"public static UintAddress {prop.Name.Split('.').Last()} {{ get; }} = new UintAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "UINT":
                    WriteLine($"public static UshortAddress {prop.Name.Split('.').Last()} {{ get; }} = new UshortAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "INT":
                    WriteLine($"public static ShortAddress {prop.Name.Split('.').Last()} {{ get; }} = new ShortAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "DINT":
                    WriteLine($"public static IntAddress {prop.Name.Split('.').Last()} {{ get; }} = new IntAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "LREAL":
                    WriteLine($"public static DoubleAddress {prop.Name.Split('.').Last()} {{ get; }} = new DoubleAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "DWORD":
                    WriteLine($"public static UintAddress {prop.Name.Split('.').Last()} {{ get; }} = new UintAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;
                case "WORD":
                    WriteLine($"public static ShortAddress {prop.Name.Split('.').Last()} {{ get; }} = new ShortAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                    break;                
                default :
                    if (prop.Type.StartsWith("STRING"))
                    {
                        WriteLine($"public static StringAddress {prop.Name.Split('.').Last()} {{ get; }} = new StringAddress({prop.BitSize}, \"{prop.Name}\", {prop.BitOffset});");
                        break;
                    }                    
                    break;
            }
}
        if (tree.Children != null)
        {
            WriteLine("");
            PrintTree(tree.Children);
}

        PopIndent();
        WriteLine("}");      


}

    // Insert copy paste-code here from ReadPlcSymbolFile


    public class ParsePlcSymbolFile
    {
        public static IEnumerable<ClassTree> ReadFile(string path)
        {
            var xml = XDocument.Load(path);
            var dataAreas = xml.Root.Descendants(XName.Get("DataArea"));
            var classNames = new List<string>();

            var symbols = new List<PlcSymbol>();

            foreach (var dataArea in dataAreas)
            {
                var distinctName = dataArea.Descendants(XName.Get("Symbol")).Elements().Where(x => x.Name == "Name").Select(y=>y.Value.ToString()).Distinct();
                foreach (var dist in distinctName)
                {
                    var splitted = dist.Split('.');
                    var currentClassName = string.Join(".", splitted.Take(splitted.Length - 1));
                    if (classNames.Any(x => x.Contains(currentClassName) && x.StartsWith(currentClassName)))
                    {
                        continue;
                    }

                    var existingClassName = classNames.SingleOrDefault(x => currentClassName.Contains(x) && currentClassName.StartsWith(x));
                    if (existingClassName != null)
                    {
                        classNames.Remove(existingClassName);
                    }

                    classNames.Add(currentClassName);
                }

                foreach (var symbol in dataArea.Descendants(XName.Get("Symbol")))
                {
                    symbols.Add(new PlcSymbol(symbol.Element("Name").Value, symbol.Element("BaseType").Value, int.Parse(symbol.Element("BitSize").Value), int.Parse(symbol.Element("BitOffs").Value)));
                }
            }

            var trees = new List<ClassTree>();

            foreach (var nameSpace in classNames.Distinct())
            {
                trees.Add(new ClassTree(nameSpace));
            }

            foreach (var plcSymbol in symbols)
            {
                MapToTree(trees, plcSymbol);
            }

            return trees;
        }

        public static void MapToTree(IEnumerable<ClassTree> trees, PlcSymbol symbol)
        {
            var choppedUpSymbol = symbol.Name.Split('.');
            var possibleTrees = trees;
            for (int i = 0; i < choppedUpSymbol.Length - 2; i++)
            {
                possibleTrees = possibleTrees.Where(x => x.Name == choppedUpSymbol[i]).Select(x => x.Children).ToArray();
            }
            if (!possibleTrees.Any())
            {
                throw new InvalidOperationException("Free flying symbol...");
            }
            possibleTrees.Single(x => x.Name == choppedUpSymbol[choppedUpSymbol.Length - 2]).AddSymbol(symbol);
        }
    }

    public class PlcSymbol
    {
        public PlcSymbol(string name, string type, int bitSize, int bitOffset)
        {
            Name = name;
            Type = type;
            BitSize = bitSize;
            BitOffset = bitOffset;
        }

        public string Name { get; }

        public string Type { get; }

        public int BitSize { get; }

        public int BitOffset { get; }
    }

    public class ClassTree
    {
        public ClassTree(string name)
        {
            Symbols = new List<PlcSymbol>();
            if (name.Contains("."))
            {
                Name = name.Remove(name.IndexOf("."));
                this.Children = new ClassTree(name.Remove(0, name.IndexOf(".") + 1));
            }
            else
            {
                Name = name;
            }
        }

        public string Name { get; }

        public ClassTree Children { get; }

        public void AddSymbol(PlcSymbol symbol)
        {
            this.Symbols.Add(symbol);
        }

        public IList<PlcSymbol> Symbols { get; }
    }
	

    //End of copy paste code
#>